#ifndef _PFGOTO_H_

/*  #include <getopt.h> */ 
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include <time.h>
#include <ctype.h>
#include <math.h>
#include <float.h>
#include "getopt.h"

#define _PFGOTO_H_

#define GAP '-'
#define real double

/* definitions essential for matrices */
#define LN10 2.3025850930
#define LN2 0.6931471806


#ifdef DMALLOC
#include "dmalloc.h"
#endif
/*  global variables */
extern char prog_name[10];
/*  extern char Version[30]; */


/* options essential for the programm */
extern int verbose_flag;

extern int typ_flag;     /* Flag set by `-DNA'=1  or `-prot'=0
			    if typ_flag == -1 the proramm decides wether the
			    input sequences are DNA or protein */

extern int PS_flag;      /* Flag set by `-PS', default is 1 =>
			    postscript output */

extern int Egap_flag;    /* Flag set by `-endgaps', the default value of
			    endgaps is 0, but can be modified by the user */

extern int matrix_flag;  /* Flag set by `-score_matrix', requires as
			    argument a matrix series */

extern int dist_flag;    /* Flag set by `-pam', default is -1,
			    set to pam distance (gon, pam) or to the
			    observed identity (blo) to select one matrix out
			    of a matrix series */

/*extern int calcS_flag;  Flag set by `-calc_s', default is 0, requires as
			     argument a filename containing only the alignment
			     encoded as one string of symbols -> calculates the
			     score of this alignment*/

/* essential global variables */
extern float BETA;       /* default value of BETA */

extern float ENDGAP;     /* default value for endgaps is set to 0 */

extern char MAT_SER[20]; /* variable stores the selected matrix series */
			 /* default: gonnet_series */

extern float DISTANCE;   /* user can specify a pam distance (gon, pam) or an
			    observed identity (blo) to determine which matrix
			    out of a scoring matrix series to use:
			    default is -1 => probA specifies the score matrix;
			    
			    if DISTANCE is positive the scoring matrix
			    closed to the value of DISTANCE is selected */ 

extern long Nr;          /* number of alignments generated by stochastic
			    backtracking */

extern char TRACK[30];   /* stores the filename containing the alignment 
			     encoded as one string of symbols; 
			     option`-calc_s' */

/*char *track;              stores the alignment encoded as one string of
			     symbols; option`-calc_s' */

/* for options.c */
extern struct option long_options[];
extern int option_index; /* getopt_long stores the option index here. */
extern char *shortopts;



typedef struct{
  int x; /* base i in the first sequence(a) */
  int y; /* base j in the second sequence(b) */
} point;

typedef struct{
  point dot;     /* P(i,j)*/ 
  int s;         /* score of the alignment*/
  int *tr;       /* code for the alignement: 1 = m/mm; 2 insertion */
 } aln;

typedef struct{
  char *name;
  char *seq;
} sequ;

typedef struct{
  char in;     /* evalute input: K from keybord; P pipe */
  int n;       /* output: only the n best alignements */
  int s;       /* output: all alignements with a score >s */
} dearg;

typedef struct{
  int **S;      /* structure contains the scoring matrices for the Gotoh- */
  int **E;      /* algorithm */
  int **F;
} mtx;

typedef struct{
  char *mono;      /* amino acid or nucleic acid order */
  double **sm;        /* scoring matrix */
} s_mat;

typedef struct{
  char *name;   
  int *s;        
} iseq;

typedef struct{
  char *name;
  double dist;       /* distance in PAM units or BLOSUM notation */
  double beta;       /* partion module depending on the scoring matrix */
  char *monomers;    /* amino or nucleic acid order */ 
  double **mat;      /* entries of the score matix */
  double endgaps;   
} u_sc;


typedef struct{
  double o; /* structure containing two doubles*/
  double e;
} two_f;

typedef struct{
  char name[20];
  double dist;        /* distance in PAM units or BLOSUM notation */
  double beta;        /* partion module depending on the scoring matrix */
  char monomers[30];  /* amino or nucleic acid order */ 
  double mat[465];    /* entries of the score matix */ 
  two_f pos;          /* gap penalties for all + matrix */  
  two_f p_n;          /* gap penalties for +/- matrix */
  double endgaps;     /* treat endgaps different from gaps in the
			 alignment default: endgaps = 0; */
} score_m;


typedef struct{
  sequ s0; /* stores the sequences as they are used in the programm */
  sequ s1; /* stores the sequences as they are used in the programm */
  char *a; /* alignment: encoded as a string of digits
	                1 | match
			2 : mismatch
	                3 _ gaps in the shorter seq(s1,E)			                       4 ^ gaps in the longer seq(s0,F) */
  double score;        /* score of the alignment */
  double prob;         /* probability of the alignment */
} aligm;

typedef struct{
  sequ s0;
  sequ s1;
  double score;
} al;

typedef struct{
  real **M; 
  real **E;
  real **F;
} matrix;

typedef struct{
  double d;      /* observed distance = matches/(matches + mismatches) */
  double pam;    /* pam distance */
} dist;


typedef struct{
  int l;         /* Number of matches = Length of the coded array */
  int **C;        /* int[][] Array containing the position of each match */
} Cod;

/* global variables essential for automatic scoring matrix selection */
extern score_m gonnet_init; /* matrix for the initial protein alignment */
extern score_m dnamt;       /* matrix for nucleic acid alignment */



/* function doing a global pairwise alignment */
extern aligm align(sequ *seq_array);
extern void free_align(aligm alig);
extern al decode_alig(aligm alig);
extern void free_al(al a);
extern void free_sequ(sequ *s);

/* partition_function(s) */
extern real **partition_f(aligm alig);
extern void free_partition_f(real **m, sequ *seq_array);
extern int length_l(sequ *seq);
extern int length_s(sequ *seq);

/* stochastic backtracking */
extern aligm stoch_backtr(aligm alig);
extern void free_stoch(aligm st);
/* for options.c */
extern sequ *input(int argc, char **argv);
extern void start(int argc, char **argv);
extern char *get_line(FILE *fp);

/* call PS-plot with function ps_plot*/
extern void ps_plot(real **P, char *wastlfile);
extern int PS_plot(sequ *so, real **P, char *wastlfile);


extern score_m **init_matseries(void);
extern void usage(int bla);

extern sequ *sequences(sequ *seq_array);
extern int check_polymer(char *seq, int l);
extern void *myspace(unsigned size);
extern score_m select_scm(score_m **matx, sequ *os, iseq *is, u_sc smat);
extern u_sc convert_matrix(score_m sm);
extern iseq *code_seq(sequ *os, u_sc s); 
extern aligm align_2(sequ *os, iseq *is, u_sc smat);
extern matrix partf(aligm a);
extern matrix revers_partf(sequ *os, iseq *is, u_sc m, aligm a);
extern real **prop_alig(sequ *o, iseq *i, u_sc m,real **z,real **r,aligm a);
extern aligm stoch_btr(matrix p, aligm a);
extern void sgenrand(unsigned long seed);
extern double genrand(void);
extern void nrerror(char *message);
extern float observed_identity(aligm a);
extern float pam_distance(float d);
extern int plus(void);
extern score_m scm_name(score_m **matx);
extern double calc_score(char *tr);
/*  extern two_f comp_aln(char *ref, char *aln ); */
/*  extern Cod cod_A(char *A); */ 

#endif 
















